/**
 * ë‹¤ì´ì–´ë¦¬ ì‘ì„± í™”ë©´
 * ì œëª©, ë‚´ìš©, ê¸°ë¶„ ì…ë ¥
 */

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  ScrollView,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { createDiary, getSuggestedTodos, acceptSuggestedTodos, getDiaryByCall } from '../api/diary';
import { getCallLog } from '../api/call';

// ê¸°ë¶„ ì˜µì…˜
const MOOD_OPTIONS = [
  { value: 'happy', label: 'í–‰ë³µí•´ìš”', emoji: 'ğŸ˜Š' },
  { value: 'excited', label: 'ì‹ ë‚˜ìš”', emoji: 'ğŸ¤—' },
  { value: 'calm', label: 'í‰ì˜¨í•´ìš”', emoji: 'ğŸ˜Œ' },
  { value: 'sad', label: 'ìŠ¬í¼ìš”', emoji: 'ğŸ˜¢' },
  { value: 'angry', label: 'í™”ë‚˜ìš”', emoji: 'ğŸ˜ ' },
  { value: 'tired', label: 'í”¼ê³¤í•´ìš”', emoji: 'ğŸ˜´' },
];

export const DiaryWriteScreen = () => {
  const router = useRouter();
  const insets = useSafeAreaInsets();
  
  // URL íŒŒë¼ë¯¸í„°ì—ì„œ í†µí™” ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  const searchParams = useLocalSearchParams();
  const fromCall = searchParams.fromCall === 'true';
  const callSid = searchParams.callSid as string | undefined;

  const [date, setDate] = useState(new Date().toISOString().split('T')[0]); // YYYY-MM-DD
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [selectedMood, setSelectedMood] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isLoadingSummary, setIsLoadingSummary] = useState(false);
  
  // TODO ê´€ë ¨ ìƒíƒœ
  const [suggestedTodos, setSuggestedTodos] = useState<any[]>([]);
  const [selectedTodos, setSelectedTodos] = useState<number[]>([]);
  const [isLoadingTodos, setIsLoadingTodos] = useState(false);
  const [showTodoSection, setShowTodoSection] = useState(false);
  const [generatedDiaryId, setGeneratedDiaryId] = useState<string | null>(null);

  /**
   * ë‚ ì§œ í¬ë§·íŒ…
   */
  const formatDateDisplay = (dateString: string): string => {
    const d = new Date(dateString);
    const year = d.getFullYear();
    const month = d.getMonth() + 1;
    const day = d.getDate();
    const days = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '];
    const dayOfWeek = days[d.getDay()];
    return `${year}ë…„ ${month}ì›” ${day}ì¼ (${dayOfWeek})`;
  };

  /**
   * ìë™ ìƒì„±ëœ ì¼ê¸° ë¶ˆëŸ¬ì˜¤ê¸°
   */
  useEffect(() => {
    const loadAutoGeneratedDiary = async () => {
      // í†µí™”ì—ì„œ ì˜¨ ê²½ìš°ì´ê³  callSidê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
      if (fromCall && callSid) {
        try {
          setIsLoadingSummary(true);
          console.log('ğŸ“ ìë™ ìƒì„±ëœ ì¼ê¸° ë¶ˆëŸ¬ì˜¤ê¸° ì‹œì‘:', callSid);
          
          // ì¼ê¸° ìƒì„± ì™„ë£Œê¹Œì§€ ëŒ€ê¸° (ìµœëŒ€ 15ì´ˆ, 3ì´ˆë§ˆë‹¤ ì¬ì‹œë„)
          let retryCount = 0;
          const maxRetries = 5;
          
          const checkDiary = async (): Promise<boolean> => {
            try {
              const diary = await getDiaryByCall(callSid);
              if (diary && diary.is_auto_generated) {
                // ìë™ ìƒì„±ëœ ì¼ê¸°ë¥¼ contentì— ì…ë ¥
                setContent(diary.content);
                setTitle('AIì™€ì˜ ëŒ€í™” ì¼ê¸°');
                setGeneratedDiaryId(diary.diary_id);
                
                console.log('âœ… ìë™ ìƒì„±ëœ ì¼ê¸° ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ');
                
                Alert.alert(
                  'âœ… ì¼ê¸° ìë™ ì™„ì„±',
                  'AIê°€ í†µí™” ë‚´ìš©ìœ¼ë¡œ ì¼ê¸°ë¥¼ ì‘ì„±í–ˆìŠµë‹ˆë‹¤!\nìˆ˜ì •í•˜ê±°ë‚˜ ê·¸ëŒ€ë¡œ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                  [{ text: 'í™•ì¸' }]
                );
                
                return true;
              }
              return false;
            } catch (error) {
              return false;
            }
          };
          
          // ì¬ì‹œë„ ë¡œì§
          const waitForDiary = async () => {
            while (retryCount < maxRetries) {
              console.log(`ğŸ“‹ ì¼ê¸° í™•ì¸ ì¤‘... (${retryCount + 1}/${maxRetries})`);
              
              const found = await checkDiary();
              if (found) {
                return true;
              }
              
              retryCount++;
              if (retryCount < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, 3000));
              }
            }
            return false;
          };
          
          const success = await waitForDiary();
          
          if (!success) {
            console.log('âš ï¸ ìë™ ìƒì„±ëœ ì¼ê¸°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
            Alert.alert(
              'ì•Œë¦¼',
              'ì¼ê¸°ê°€ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\nì§ì ‘ ì‘ì„±í•´ì£¼ì„¸ìš”.'
            );
          }
          
        } catch (error) {
          console.error('âŒ ì¼ê¸° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
          Alert.alert(
            'ì•Œë¦¼',
            'ì¼ê¸°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\nì§ì ‘ ì‘ì„±í•´ì£¼ì„¸ìš”.'
          );
        } finally {
          setIsLoadingSummary(false);
        }
      }
    };

    loadAutoGeneratedDiary();
    
    // TODO ë¡œë”©ë„ í•¨ê»˜ ì‹¤í–‰
    loadSuggestedTodos();
  }, [fromCall, callSid]);

  /**
   * ê°ì§€ëœ TODO ë¶ˆëŸ¬ì˜¤ê¸°
   */
  const loadSuggestedTodos = async () => {
    if (!fromCall || !callSid) return;
    
    try {
      setIsLoadingTodos(true);
      console.log('ğŸ“‹ ê°ì§€ëœ TODO ë¶ˆëŸ¬ì˜¤ê¸° ì‹œì‘');
      
      // TODO ì¡°íšŒ (ìµœëŒ€ 15ì´ˆê¹Œì§€ ì¬ì‹œë„)
      let retryCount = 0;
      const maxRetries = 5;
      
      const checkTodos = async (): Promise<boolean> => {
        try {
          const diary = await getDiaryByCall(callSid);
          if (diary && diary.is_auto_generated) {
            setGeneratedDiaryId(diary.diary_id);
            
            const todos = await getSuggestedTodos(diary.diary_id);
            if (todos.suggested_todos && todos.suggested_todos.length > 0) {
              setSuggestedTodos(todos.suggested_todos);
              setShowTodoSection(true);
              console.log(`ğŸ“Œ ${todos.suggested_todos.length}ê°œì˜ TODO ê°ì§€ë¨`);
              return true;
            }
          }
          return false;
        } catch (error) {
          return false;
        }
      };
      
      // ì¬ì‹œë„ ë¡œì§
      const waitForTodos = async () => {
        while (retryCount < maxRetries) {
          console.log(`ğŸ“‹ TODO í™•ì¸ ì¤‘... (${retryCount + 1}/${maxRetries})`);
          
          const found = await checkTodos();
          if (found) {
            setIsLoadingTodos(false);
            return;
          }
          
          retryCount++;
          if (retryCount < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 3000));
          }
        }
        setIsLoadingTodos(false);
        console.log('âš ï¸ TODOë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
      };
      
      waitForTodos();
      
    } catch (error) {
      console.error('âŒ TODO ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
      setIsLoadingTodos(false);
    }
  };

  /**
   * TODO ì„ íƒ/í•´ì œ
   */
  const toggleTodoSelection = (index: number) => {
    setSelectedTodos(prev => 
      prev.includes(index) 
        ? prev.filter(i => i !== index)
        : [...prev, index]
    );
  };

  /**
   * ì„ íƒëœ TODO ë“±ë¡
   */
  const handleAcceptTodos = async () => {
    if (selectedTodos.length === 0) {
      Alert.alert('ì•Œë¦¼', 'ë“±ë¡í•  í•  ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
      return;
    }

    try {
      setIsSubmitting(true);
      console.log('ğŸ“ ì„ íƒëœ TODO ë“±ë¡ ì‹œì‘:', selectedTodos);
      
      if (!generatedDiaryId) {
        Alert.alert('ì˜¤ë¥˜', 'ì¼ê¸° ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      
      const result = await acceptSuggestedTodos(generatedDiaryId, selectedTodos);
      console.log('âœ… TODO ë“±ë¡ ì™„ë£Œ:', result);
      
      Alert.alert(
        'ì™„ë£Œ',
        `${result.created_todos_count}ê°œì˜ í•  ì¼ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ“‹`,
        [{ text: 'í™•ì¸' }]
      );
      
      // TODO ì„¹ì…˜ ìˆ¨ê¸°ê¸°
      setShowTodoSection(false);
      setSelectedTodos([]);
      
    } catch (error: any) {
      console.error('âŒ TODO ë“±ë¡ ì‹¤íŒ¨:', error);
      Alert.alert(
        'ì˜¤ë¥˜',
        error.response?.data?.detail || 'í•  ì¼ ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.'
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  /**
   * ì¼ê¸° ì €ì¥
   */
  const handleSubmit = async () => {
    // ìœ íš¨ì„± ê²€ì‚¬
    if (!title.trim()) {
      Alert.alert('ì•Œë¦¼', 'ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }

    if (!selectedMood) {
      Alert.alert('ì•Œë¦¼', 'ì˜¤ëŠ˜ì˜ ê¸°ë¶„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
      return;
    }

    if (!content.trim()) {
      Alert.alert('ì•Œë¦¼', 'ì¼ê¸° ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }

    try {
      setIsSubmitting(true);

      await createDiary({
        date,
        title: title.trim(),
        content: content.trim(),
        mood: selectedMood,
        status: 'published',
      });

      // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
      Alert.alert(
        'ì™„ë£Œ',
        'ì¼ê¸°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ“',
        [
          {
            text: 'í™•ì¸',
            onPress: () => {
              // í†µí™”ì—ì„œ ì˜¨ ê²½ìš° ë©”ì¸ í˜ì´ì§€ë¡œ, ì•„ë‹ˆë©´ ë‹¤ì´ì–´ë¦¬ ëª©ë¡ìœ¼ë¡œ ì´ë™
              if (fromCall) {
                // í†µí™” â†’ ë‹¤ì´ì–´ë¦¬ ì‘ì„± â†’ ë©”ì¸ (ë’¤ë¡œê°€ê¸° ìŠ¤íƒ ì´ˆê¸°í™”)
                router.replace('/home');
              } else {
                // ì¼ë°˜ ë‹¤ì´ì–´ë¦¬ ì‘ì„± â†’ ë‹¤ì´ì–´ë¦¬ ëª©ë¡
                router.replace('/diaries');
              }
            },
          },
        ]
      );

    } catch (error: any) {
      console.error('ì¼ê¸° ì €ì¥ ì‹¤íŒ¨:', error);
      Alert.alert(
        'ì˜¤ë¥˜',
        error.response?.data?.detail || 'ì¼ê¸° ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.'
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      {/* í—¤ë” */}
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => {
            // í†µí™”ì—ì„œ ì˜¨ ê²½ìš° ë©”ì¸ìœ¼ë¡œ, ì•„ë‹ˆë©´ ë’¤ë¡œê°€ê¸°
            if (fromCall) {
              router.replace('/home');
            } else {
              router.back();
            }
          }}
          style={styles.backButton}
          disabled={isSubmitting}
        >
          <Text style={styles.backButtonText}>â†</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>ì¼ê¸° ì‘ì„±</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        showsVerticalScrollIndicator={false}
      >
        {/* ì¼ê¸° ìƒì„± ë¡œë”© ì¸ë””ì¼€ì´í„° */}
        {isLoadingSummary && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="small" color="#4A90E2" />
            <Text style={styles.loadingText}>AIê°€ ì¼ê¸°ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘...</Text>
          </View>
        )}

        {/* TODO ë¡œë”© ì¸ë””ì¼€ì´í„° */}
        {isLoadingTodos && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="small" color="#34B79F" />
            <Text style={styles.loadingText}>ê°ì§€ëœ í•  ì¼ì„ í™•ì¸í•˜ëŠ” ì¤‘...</Text>
          </View>
        )}

        {/* ê°ì§€ëœ TODO ì„¹ì…˜ */}
        {showTodoSection && suggestedTodos.length > 0 && (
          <View style={styles.todoSection}>
            <Text style={styles.todoSectionTitle}>ğŸ¤– AIê°€ ê°ì§€í•œ í•  ì¼</Text>
            <Text style={styles.todoSectionSubtitle}>
              í†µí™” ë‚´ìš©ì—ì„œ ê°ì§€ëœ í•  ì¼ì…ë‹ˆë‹¤. ë“±ë¡í•˜ê³  ì‹¶ì€ í•­ëª©ì„ ì„ íƒí•´ì£¼ì„¸ìš”.
            </Text>
            
            {suggestedTodos.map((todo, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  styles.todoItem,
                  selectedTodos.includes(index) && styles.todoItemSelected
                ]}
                onPress={() => toggleTodoSelection(index)}
                disabled={isSubmitting}
              >
                <View style={styles.todoItemContent}>
                  <Text style={styles.todoItemTitle}>{todo.title}</Text>
                  {todo.description && (
                    <Text style={styles.todoItemDescription}>{todo.description}</Text>
                  )}
                  <View style={styles.todoItemMeta}>
                    <Text style={styles.todoItemDate}>
                      ğŸ“… {todo.due_date ? new Date(todo.due_date).toLocaleDateString('ko-KR') : 'ë‚ ì§œ ë¯¸ì •'}
                    </Text>
                    <Text style={[
                      styles.todoItemPriority,
                      { color: todo.priority === 'high' ? '#FF6B6B' : todo.priority === 'medium' ? '#FFA726' : '#66BB6A' }
                    ]}>
                      {todo.priority === 'high' ? 'ğŸ”´ ë†’ìŒ' : todo.priority === 'medium' ? 'ğŸŸ¡ ë³´í†µ' : 'ğŸŸ¢ ë‚®ìŒ'}
                    </Text>
                  </View>
                </View>
                <View style={[
                  styles.todoCheckbox,
                  selectedTodos.includes(index) && styles.todoCheckboxSelected
                ]}>
                  {selectedTodos.includes(index) && (
                    <Text style={styles.todoCheckmark}>âœ“</Text>
                  )}
                </View>
              </TouchableOpacity>
            ))}
            
            <View style={styles.todoActions}>
              <TouchableOpacity
                style={[
                  styles.todoActionButton,
                  selectedTodos.length === 0 && styles.todoActionButtonDisabled
                ]}
                onPress={handleAcceptTodos}
                disabled={selectedTodos.length === 0 || isSubmitting}
              >
                <Text style={[
                  styles.todoActionButtonText,
                  selectedTodos.length === 0 && styles.todoActionButtonTextDisabled
                ]}>
                  ğŸ“‹ ì„ íƒí•œ í•  ì¼ ë“±ë¡ ({selectedTodos.length}ê°œ)
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={styles.todoSkipButton}
                onPress={() => setShowTodoSection(false)}
                disabled={isSubmitting}
              >
                <Text style={styles.todoSkipButtonText}>ê±´ë„ˆë›°ê¸°</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}

        {/* ë‚ ì§œ (ìˆ¨ê¹€ - ìë™ìœ¼ë¡œ ì˜¤ëŠ˜ ë‚ ì§œ) */}
        <View style={styles.section}>
          <Text style={styles.dateText}>{formatDateDisplay(date)}</Text>
        </View>

        {/* ì œëª© */}
        <View style={styles.section}>
          <Text style={styles.sectionLabel}>ì œëª©</Text>
          <TextInput
            style={styles.titleInput}
            placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
            placeholderTextColor="#CCCCCC"
            value={title}
            onChangeText={setTitle}
            maxLength={100}
            editable={!isSubmitting}
          />
        </View>

        {/* ê¸°ë¶„ */}
        <View style={styles.section}>
          <Text style={styles.sectionLabel}>ì˜¤ëŠ˜ì˜ ê¸°ë¶„</Text>
          <View style={styles.moodGrid}>
            {MOOD_OPTIONS.map((mood) => (
              <TouchableOpacity
                key={mood.value}
                style={[
                  styles.moodButton,
                  selectedMood === mood.value && styles.moodButtonSelected,
                ]}
                onPress={() => setSelectedMood(mood.value)}
                disabled={isSubmitting}
              >
                <Text style={styles.moodEmoji}>{mood.emoji}</Text>
                <Text
                  style={[
                    styles.moodLabel,
                    selectedMood === mood.value && styles.moodLabelSelected,
                  ]}
                >
                  {mood.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* ë‚´ìš© */}
        <View style={styles.section}>
          <Text style={styles.sectionLabel}>ì¼ê¸° ë‚´ìš©</Text>
          <TextInput
            style={styles.contentInput}
            placeholder="ì˜¤ëŠ˜ í•˜ë£¨ëŠ” ì–´ë– ì…¨ë‚˜ìš”?&#10;ì¼ì–´ë‚œ ì¼ì´ë‚˜ ëŠë‚€ ì ì„ ììœ ë¡­ê²Œ ì‘ì„±í•´ë³´ì„¸ìš”."
            placeholderTextColor="#CCCCCC"
            value={content}
            onChangeText={setContent}
            multiline
            numberOfLines={15}
            textAlignVertical="top"
            editable={!isSubmitting}
          />
          <Text style={styles.charCount}>{content.length}ì</Text>
        </View>

        {/* ì €ì¥ ë²„íŠ¼ */}
        <TouchableOpacity
          onPress={handleSubmit}
          style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <ActivityIndicator size="small" color="#FFFFFF" />
          ) : (
            <Text style={styles.submitButtonText}>âœï¸ ì‘ì„±í•˜ê¸°</Text>
          )}
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#E8E8E8',
  },
  backButton: {
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  backButtonText: {
    fontSize: 28,
    color: '#333333',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#333333',
  },
  placeholder: {
    width: 40,
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: 20,
    paddingBottom: 100,
  },
  section: {
    marginBottom: 24,
  },
  sectionLabel: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333333',
    marginBottom: 12,
  },
  dateText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#34B79F',
    textAlign: 'center',
  },
  titleInput: {
    fontSize: 18,
    color: '#333333',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: '#E8E8E8',
    borderRadius: 12,
    backgroundColor: '#FFFFFF',
  },
  moodGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
  },
  moodButton: {
    width: '30%',
    paddingVertical: 16,
    backgroundColor: '#F8F8F8',
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: 'transparent',
  },
  moodButtonSelected: {
    backgroundColor: '#E8F5F2',
    borderColor: '#34B79F',
  },
  moodEmoji: {
    fontSize: 26,
    marginBottom: 4,
  },
  moodLabel: {
    fontSize: 12,
    fontWeight: '500',
    color: '#666666',
  },
  moodLabelSelected: {
    color: '#34B79F',
    fontWeight: '700',
  },
  contentInput: {
    fontSize: 16,
    lineHeight: 24,
    color: '#333333',
    padding: 16,
    borderWidth: 1,
    borderColor: '#E8E8E8',
    borderRadius: 12,
    backgroundColor: '#FFFFFF',
    minHeight: 240,
  },
  charCount: {
    fontSize: 13,
    color: '#999999',
    textAlign: 'right',
    marginTop: 8,
  },
  submitButton: {
    width: '100%',
    height: 56,
    backgroundColor: '#34B79F',
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 24,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 4,
  },
  submitButtonDisabled: {
    backgroundColor: '#CCCCCC',
  },
  submitButtonText: {
    fontSize: 18,
    fontWeight: '700',
    color: '#FFFFFF',
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    backgroundColor: '#F0F8FF',
    borderRadius: 12,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#D0E8FF',
  },
  loadingText: {
    marginLeft: 8,
    fontSize: 14,
    color: '#4A90E2',
    fontWeight: '500',
  },
  // TODO ì„¹ì…˜ ìŠ¤íƒ€ì¼
  todoSection: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 20,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#E8F5F2',
  },
  todoSectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#34B79F',
    marginBottom: 8,
  },
  todoSectionSubtitle: {
    fontSize: 14,
    color: '#666666',
    marginBottom: 16,
    lineHeight: 20,
  },
  todoItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 2,
    borderColor: '#E8E8E8',
  },
  todoItemSelected: {
    borderColor: '#34B79F',
    backgroundColor: '#F0F8F5',
  },
  todoItemContent: {
    flex: 1,
  },
  todoItemTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333333',
    marginBottom: 4,
  },
  todoItemDescription: {
    fontSize: 14,
    color: '#666666',
    marginBottom: 8,
  },
  todoItemMeta: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  todoItemDate: {
    fontSize: 12,
    color: '#999999',
  },
  todoItemPriority: {
    fontSize: 12,
    fontWeight: '600',
  },
  todoCheckbox: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#CCCCCC',
    alignItems: 'center',
    justifyContent: 'center',
    marginLeft: 12,
  },
  todoCheckboxSelected: {
    backgroundColor: '#34B79F',
    borderColor: '#34B79F',
  },
  todoCheckmark: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  todoActions: {
    marginTop: 16,
  },
  todoActionButton: {
    backgroundColor: '#34B79F',
    borderRadius: 12,
    paddingVertical: 14,
    paddingHorizontal: 20,
    alignItems: 'center',
    marginBottom: 12,
  },
  todoActionButtonDisabled: {
    backgroundColor: '#CCCCCC',
  },
  todoActionButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  todoActionButtonTextDisabled: {
    color: '#999999',
  },
  todoSkipButton: {
    alignItems: 'center',
    paddingVertical: 8,
  },
  todoSkipButtonText: {
    color: '#999999',
    fontSize: 14,
  },
});

export default DiaryWriteScreen;

