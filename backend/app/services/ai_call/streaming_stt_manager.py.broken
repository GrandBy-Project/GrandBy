"""
Google Cloud Speech-to-Text Streaming Manager
ì‹¤ì‹œê°„ STT ìŠ¤íŠ¸ë¦¬ë°ì„ ìœ„í•œ ì™„ì „íˆ ìƒˆë¡œìš´ êµ¬í˜„

Features:
- ì§„ì •í•œ ë¹„ë™ê¸° ìŠ¤íŠ¸ë¦¬ë° (asyncio ê¸°ë°˜)
- ì¤‘ê°„ ê²°ê³¼ + ìµœì¢… ê²°ê³¼ ì‹¤ì‹œê°„ ìˆ˜ì‹ 
- ìë™ ì„¸ì…˜ ì¬ì‹œì‘ (Google 305ì´ˆ ì œí•œ ëŒ€ì‘)
- ë°œí™” ë‹¨ìœ„ ìë™ ê°ì§€
- ì—ëŸ¬ ì²˜ë¦¬ ë° ìë™ ë³µêµ¬
"""

from google.cloud import speech_v1p1beta1 as speech
from google.api_core import exceptions as google_exceptions
import asyncio
import logging
from typing import AsyncGenerator, Optional, Dict
import time
import os
from app.config import settings

logger = logging.getLogger(__name__)


class StreamingSTTManager:
    """
    Google Cloud STT ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë° ê´€ë¦¬ì

    Architecture:
    - Producer: add_audio() â†’ audio_queue
    - Consumer: _audio_generator() â†’ Google Cloud API
    - Results: start_streaming() yields results in real-time
    """

    def __init__(self, call_sid: str):
        self.call_sid = call_sid
        self.is_active = False
        self.audio_queue: asyncio.Queue = asyncio.Queue()

        # Google Cloud Speech Client ì´ˆê¸°í™”
        self._init_google_client()

        # ìŠ¤íŠ¸ë¦¬ë° ì„¤ì •
        self.config = self._create_recognition_config()
        self.streaming_config = self._create_streaming_config()

        # ì„¸ì…˜ ê´€ë¦¬
        self.session_start_time = 0
        self.max_session_duration = 300  # 5ë¶„ (Google ì œí•œ: 305ì´ˆ)
        self.total_audio_duration = 0  # ì „ì†¡ëœ ì˜¤ë””ì˜¤ ì´ ì‹œê°„

        # í†µê³„
        self.interim_count = 0
        self.final_count = 0
        self.error_count = 0

        logger.info(f"ğŸ™ï¸ [StreamingSTT] ì´ˆê¸°í™” ì™„ë£Œ - Call: {call_sid}")

    def _init_google_client(self):
        """Google Cloud Speech Client ì´ˆê¸°í™”"""
        try:
            # í™˜ê²½ ë³€ìˆ˜ì—ì„œ ì¸ì¦ ì •ë³´ ì„¤ì •
            credentials_path = settings.GOOGLE_APPLICATION_CREDENTIALS
            if os.path.exists(credentials_path):
                os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = credentials_path
                logger.info(f"âœ… Google Cloud ì¸ì¦: {credentials_path}")
            else:
                raise FileNotFoundError(f"ì¸ì¦ íŒŒì¼ ì—†ìŒ: {credentials_path}")

            self.client = speech.SpeechClient()
            logger.info("âœ… Google Cloud Speech Client ì´ˆê¸°í™” ì„±ê³µ")

        except Exception as e:
            logger.error(f"âŒ Google Cloud Client ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise

    def _create_recognition_config(self) -> speech.RecognitionConfig:
        """STT ì¸ì‹ ì„¤ì • ìƒì„±"""
        config = speech.RecognitionConfig(
            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,  # Twilio mulaw
            sample_rate_hertz=8000,  # Twilio 8kHz
            language_code=settings.GOOGLE_STT_LANGUAGE_CODE,
            model=settings.GOOGLE_STT_MODEL,  # phone_call

            # í’ˆì§ˆ í–¥ìƒ ì˜µì…˜
            enable_automatic_punctuation=True,
            use_enhanced=True,

            # ìƒì„¸ ì •ë³´
            max_alternatives=settings.GOOGLE_STT_MAX_ALTERNATIVES,
            profanity_filter=False,
            enable_word_time_offsets=False,  # Streamingì—ì„œëŠ” ë¶ˆí•„ìš”
        )

        logger.info(f"ğŸ”§ [StreamingSTT] ì¸ì‹ ì„¤ì •:")
        logger.info(f"   - ì–¸ì–´: {config.language_code}")
        logger.info(f"   - ëª¨ë¸: {config.model}")
        logger.info(f"   - ìƒ˜í”Œë ˆì´íŠ¸: {config.sample_rate_hertz}Hz")
        logger.info(f"   - ì¸ì½”ë”©: MULAW")

        return config

    def _create_streaming_config(self) -> speech.StreamingRecognitionConfig:
        """ìŠ¤íŠ¸ë¦¬ë° ì„¤ì • ìƒì„±"""
        streaming_config = speech.StreamingRecognitionConfig(
            config=self.config,
            interim_results=settings.GOOGLE_STT_INTERIM_RESULTS,  # True
            single_utterance=settings.GOOGLE_STT_SINGLE_UTTERANCE,  # False
        )

        logger.info(f"ğŸ”§ [StreamingSTT] ìŠ¤íŠ¸ë¦¬ë° ì„¤ì •:")
        logger.info(f"   - ì¤‘ê°„ ê²°ê³¼: {streaming_config.interim_results}")
        logger.info(f"   - ë‹¨ì¼ ë°œí™”: {streaming_config.single_utterance}")

        return streaming_config

    async def add_audio(self, audio_data: bytes):
        """
        ì˜¤ë””ì˜¤ ì²­í¬ë¥¼ ìŠ¤íŠ¸ë¦¼ì— ì¶”ê°€

        Args:
            audio_data: mulaw í¬ë§· ì˜¤ë””ì˜¤ (Twilioì—ì„œ ì „ì†¡, 20ms ì²­í¬)
        """
        if not self.is_active:
            logger.warning(f"âš ï¸ [StreamingSTT] ë¹„í™œì„± ìƒíƒœ - ì˜¤ë””ì˜¤ ë¬´ì‹œ")
            return

        # ì„¸ì…˜ ì‹œê°„ ì œí•œ ì²´í¬ (5ë¶„ë§ˆë‹¤ ìë™ ì¬ì‹œì‘)
        current_duration = time.time() - self.session_start_time
        if current_duration > self.max_session_duration:
            logger.warning(f"â° [StreamingSTT] ì„¸ì…˜ ì‹œê°„ ì´ˆê³¼ ({current_duration:.1f}ì´ˆ) - ì¬ì‹œì‘ í•„ìš”")
            # ì‹¤ì œ ì¬ì‹œì‘ì€ ìƒìœ„ ë ˆì´ì–´ì—ì„œ ì²˜ë¦¬
            return

        # ì˜¤ë””ì˜¤ íì— ì¶”ê°€
        await self.audio_queue.put(audio_data)

        # í†µê³„ ì—…ë°ì´íŠ¸ (20ms per chunk)
        self.total_audio_duration += 0.02

    def _request_generator(self):
        """
        ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­ ìƒì„±ê¸° (ë™ê¸° generator)

        Google Cloud APIëŠ” ë™ê¸° generatorë¥¼ ìš”êµ¬í•˜ë¯€ë¡œ
        queue.Queueë¥¼ ì‚¬ìš© (asyncio.Queue ì•„ë‹˜!)

        Yields:
            StreamingRecognizeRequest
        """
        import queue
        import threading

        # ì²« ìš”ì²­: ì„¤ì • ì •ë³´ ì „ì†¡
        logger.info(f"ğŸ“¤ [StreamingSTT] ì²« ìš”ì²­: ì„¤ì • ì „ì†¡")
        yield speech.StreamingRecognizeRequest(streaming_config=self.streaming_config)

        # ì´í›„ ìš”ì²­: ì˜¤ë””ì˜¤ ë°ì´í„° ì „ì†¡
        chunk_count = 0

        # asyncio.Queueì—ì„œ ë™ê¸° queueë¡œ ë°ì´í„° ì „ë‹¬í•˜ëŠ” í—¬í¼
        sync_queue = queue.Queue()

        def transfer_from_async_queue():
            """asyncio.Queue â†’ queue.Queue ì „ë‹¬ (ë³„ë„ ìŠ¤ë ˆë“œ)"""
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            async def transfer():
                while self.is_active:
                    try:
                        audio_data = await asyncio.wait_for(
                            self.audio_queue.get(),
                            timeout=0.1
                        )
                        sync_queue.put(audio_data)
                    except asyncio.TimeoutError:
                        continue
                    except Exception as e:
                        logger.error(f"âŒ [StreamingSTT] í ì „ë‹¬ ì˜¤ë¥˜: {e}")
                        break

            loop.run_until_complete(transfer())

        # ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ í ì „ë‹¬ ì‹œì‘
        transfer_thread = threading.Thread(target=transfer_from_async_queue, daemon=True)
        transfer_thread.start()

        while self.is_active:
            try:
                # ë™ê¸° íì—ì„œ ê°€ì ¸ì˜¤ê¸° (íƒ€ì„ì•„ì›ƒ 0.1ì´ˆ)
                audio_data = sync_queue.get(timeout=0.1)

                chunk_count += 1

                # ë””ë²„ê·¸ ë¡œê·¸ (100ê°œë§ˆë‹¤)
                if chunk_count % 100 == 0:
                    logger.debug(f"ğŸ“¤ [StreamingSTT] ì „ì†¡: {chunk_count}ê°œ ì²­í¬ ({self.total_audio_duration:.1f}ì´ˆ)")

                # ì˜¤ë””ì˜¤ ë°ì´í„° ìš”ì²­ ìƒì„±
                yield speech.StreamingRecognizeRequest(audio_content=audio_data)

            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"âŒ [StreamingSTT] ìš”ì²­ ìƒì„± ì˜¤ë¥˜: {e}")
                break

        logger.info(f"ğŸ›‘ [StreamingSTT] ìš”ì²­ ìƒì„±ê¸° ì¢…ë£Œ - ì´ {chunk_count}ê°œ ì²­í¬ ì „ì†¡")

    async def start_streaming(self) -> AsyncGenerator[Dict, None]:
        """
        ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘ ë° ê²°ê³¼ ë°˜í™˜

        Yields:
            {
                'text': str,           # ì¸ì‹ëœ í…ìŠ¤íŠ¸
                'is_final': bool,      # ìµœì¢… ê²°ê³¼ ì—¬ë¶€
                'confidence': float,   # ì‹ ë¢°ë„ (0.0~1.0, finalë§Œ ì œê³µ)
                'stability': float     # ì•ˆì •ì„± (0.0~1.0, interimë§Œ ì œê³µ)
            }
        """
        import queue
        import threading

        self.is_active = True
        self.session_start_time = time.time()
        self.interim_count = 0
        self.final_count = 0

        logger.info(f"ğŸ¬ [StreamingSTT] ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘ - Call: {self.call_sid}")

        # ê²°ê³¼ë¥¼ ë°›ì„ í (ìŠ¤ë ˆë“œ ê°„ í†µì‹ )
        result_queue = queue.Queue()

        def run_streaming():
            """ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ Google Cloud Streaming ì‹¤í–‰"""
            try:
                logger.info(f"ğŸŒ [StreamingSTT Thread] Google Cloud API í˜¸ì¶œ ì‹œì‘")

                # Google Cloud API í˜¸ì¶œ (ë™ê¸° í˜¸ì¶œ)
                responses = self.client.streaming_recognize(
                    self.streaming_config,
                    self._request_generator()
                )

                logger.info(f"âœ… [StreamingSTT Thread] API ì—°ê²° ì„±ê³µ - ê²°ê³¼ ìˆ˜ì‹  ì‹œì‘")

                # ê²°ê³¼ ì²˜ë¦¬
                for response in responses:
                    if not self.is_active:
                        break

                    if not response.results:
                        continue

                    # ì²« ë²ˆì§¸ ê²°ê³¼ ì²˜ë¦¬
                    result = response.results[0]
                    if not result.alternatives:
                        continue

                    alternative = result.alternatives[0]
                    transcript = alternative.transcript
                    is_final = result.is_final

                    # ë¹ˆ í…ìŠ¤íŠ¸ ë¬´ì‹œ
                    if not transcript or not transcript.strip():
                        continue

                    # ê²°ê³¼ ë”•ì…”ë„ˆë¦¬ ìƒì„±
                    result_dict = {
                        'text': transcript,
                        'is_final': is_final,
                        'confidence': getattr(alternative, 'confidence', 0.0) if is_final else 0.0,
                        'stability': getattr(result, 'stability', 0.0) if not is_final else 0.0
                    }

                    # íì— ê²°ê³¼ ì¶”ê°€
                    result_queue.put(result_dict)

                # ì¢…ë£Œ ì‹œê·¸ë„
                result_queue.put(None)

            except Exception as e:
                logger.error(f"âŒ [StreamingSTT Thread] ì˜¤ë¥˜: {e}")
                import traceback
                logger.error(traceback.format_exc())
                result_queue.put(None)

        # ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ì‹œì‘
        streaming_thread = threading.Thread(target=run_streaming, daemon=True)
        streaming_thread.start()
        logger.info(f"ğŸš€ [StreamingSTT] ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ì‹œì‘ë¨")

        try:
            # ê²°ê³¼ íì—ì„œ ì½ê¸° (ë¹„ë™ê¸°ë¡œ ë³€í™˜)
            while self.is_active:
                try:
                    # 0.1ì´ˆë§ˆë‹¤ í ì²´í¬
                    await asyncio.sleep(0.1)

                    # íì—ì„œ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸° (ë…¼ë¸”ë¡œí‚¹)
                    try:
                        result_dict = result_queue.get_nowait()
                    except queue.Empty:
                        continue

                    # ì¢…ë£Œ ì‹œê·¸ë„
                    if result_dict is None:
                        break

                    # í†µê³„ ì—…ë°ì´íŠ¸
                    if result_dict['is_final']:
                        self.final_count += 1
                        logger.info(f"âœ… [STT Final #{self.final_count}] {result_dict['text'][:50]}... "
                                   f"(ì‹ ë¢°ë„: {result_dict['confidence']:.2f})")
                    else:
                        self.interim_count += 1
                        logger.debug(f"â³ [STT Interim #{self.interim_count}] {result_dict['text'][:30]}... "
                                    f"(ì•ˆì •ì„±: {result_dict['stability']:.2f})")

                    # ê²°ê³¼ yield
                    yield result_dict

                except Exception as e:
                    logger.error(f"âŒ [StreamingSTT] ê²°ê³¼ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
                    break

            logger.info(f"ğŸ [StreamingSTT] ìŠ¤íŠ¸ë¦¬ë° ì¢…ë£Œ - "
                       f"ìµœì¢…: {self.final_count}ê°œ, ì¤‘ê°„: {self.interim_count}ê°œ")

        except google_exceptions.GoogleAPICallError as e:
                result = response.results[0]
                if not result.alternatives:
                    continue

                alternative = result.alternatives[0]
                transcript = alternative.transcript
                is_final = result.is_final

                # ë¹ˆ í…ìŠ¤íŠ¸ ë¬´ì‹œ
                if not transcript or not transcript.strip():
                    continue

                # ê²°ê³¼ ë”•ì…”ë„ˆë¦¬ ìƒì„±
                result_dict = {
                    'text': transcript,
                    'is_final': is_final,
                    'confidence': 0.0,
                    'stability': 0.0
                }

                if is_final:
                    # ìµœì¢… ê²°ê³¼
                    self.final_count += 1
                    result_dict['confidence'] = getattr(alternative, 'confidence', 0.0)

                    logger.info(f"âœ… [STT Final #{self.final_count}] {transcript[:50]}... "
                               f"(ì‹ ë¢°ë„: {result_dict['confidence']:.2f})")

                else:
                    # ì¤‘ê°„ ê²°ê³¼
                    self.interim_count += 1
                    result_dict['stability'] = getattr(result, 'stability', 0.0)

                    # ì¤‘ê°„ ê²°ê³¼ëŠ” ë””ë²„ê·¸ ë ˆë²¨ë¡œë§Œ ë¡œê¹…
                    logger.debug(f"â³ [STT Interim #{self.interim_count}] {transcript[:30]}... "
                                f"(ì•ˆì •ì„±: {result_dict['stability']:.2f})")

                # ê²°ê³¼ yield
                yield result_dict

            logger.info(f"ğŸ [StreamingSTT] ìŠ¤íŠ¸ë¦¬ë° ì¢…ë£Œ - "
                       f"ìµœì¢…: {self.final_count}ê°œ, ì¤‘ê°„: {self.interim_count}ê°œ")

        except google_exceptions.GoogleAPICallError as e:
            self.error_count += 1
            logger.error(f"âŒ [StreamingSTT] Google API ì˜¤ë¥˜: {e}")

        except Exception as e:
            self.error_count += 1
            logger.error(f"âŒ [StreamingSTT] ìŠ¤íŠ¸ë¦¬ë° ì˜¤ë¥˜: {e}")
            import traceback
            logger.error(traceback.format_exc())

        finally:
            self.is_active = False
            session_duration = time.time() - self.session_start_time
            logger.info(f"ğŸ›‘ [StreamingSTT] ì„¸ì…˜ ì¢…ë£Œ - "
                       f"ì‹œê°„: {session_duration:.1f}ì´ˆ, "
                       f"ì˜¤ë””ì˜¤: {self.total_audio_duration:.1f}ì´ˆ, "
                       f"ì˜¤ë¥˜: {self.error_count}ê°œ")

    async def stop(self):
        """ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì§€"""
        logger.info(f"ğŸ›‘ [StreamingSTT] ì¤‘ì§€ ìš”ì²­ - Call: {self.call_sid}")
        self.is_active = False

        # í ë¹„ìš°ê¸°
        while not self.audio_queue.empty():
            try:
                self.audio_queue.get_nowait()
            except asyncio.QueueEmpty:
                break

    def get_stats(self) -> Dict:
        """
        ìŠ¤íŠ¸ë¦¬ë° í†µê³„ ë°˜í™˜

        Returns:
            dict: í†µê³„ ì •ë³´
        """
        return {
            'call_sid': self.call_sid,
            'is_active': self.is_active,
            'interim_count': self.interim_count,
            'final_count': self.final_count,
            'error_count': self.error_count,
            'total_audio_duration': round(self.total_audio_duration, 2),
            'session_duration': round(time.time() - self.session_start_time, 2) if self.is_active else 0,
            'queue_size': self.audio_queue.qsize()
        }


class StreamingSTTSession:
    """
    ë‹¨ì¼ í†µí™”ë¥¼ ìœ„í•œ STT ì„¸ì…˜ ê´€ë¦¬ì

    Features:
    - ìë™ ì„¸ì…˜ ì¬ì‹œì‘ (5ë¶„ë§ˆë‹¤)
    - ë°œí™” ë‹¨ìœ„ í…ìŠ¤íŠ¸ ëˆ„ì 
    - ìµœì¢… ê²°ê³¼ë§Œ ìƒìœ„ ë ˆì´ì–´ì— ì „ë‹¬
    """

    def __init__(self, call_sid: str):
        self.call_sid = call_sid
        self.manager: Optional[StreamingSTTManager] = None
        self.is_running = False

        # ë°œí™” ë‹¨ìœ„ ë²„í¼
        self.current_utterance = []  # ì¤‘ê°„ ê²°ê³¼ ëˆ„ì 
        self.utterance_buffer = []   # ìµœì¢… ë°œí™” ëª©ë¡

        logger.info(f"ğŸ“ [STTSession] ìƒì„± - Call: {call_sid}")

    async def initialize(self):
        """ì„¸ì…˜ ì´ˆê¸°í™”"""
        try:
            self.manager = StreamingSTTManager(self.call_sid)
            self.is_running = True
            logger.info(f"âœ… [STTSession] ì´ˆê¸°í™” ì™„ë£Œ - Call: {self.call_sid}")
        except Exception as e:
            logger.error(f"âŒ [STTSession] ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise

    async def add_audio(self, audio_data: bytes):
        """ì˜¤ë””ì˜¤ ì¶”ê°€"""
        if self.manager and self.is_running:
            await self.manager.add_audio(audio_data)

    async def process_results(self) -> AsyncGenerator[str, None]:
        """
        STT ê²°ê³¼ ì²˜ë¦¬ ë° ìµœì¢… ë°œí™” ë°˜í™˜

        Yields:
            str: ì™„ì„±ëœ ë°œí™” í…ìŠ¤íŠ¸
        """
        if not self.manager:
            return

        try:
            async for result in self.manager.start_streaming():
                if result['is_final']:
                    # ìµœì¢… ê²°ê³¼ â†’ ì¦‰ì‹œ yield
                    final_text = result['text'].strip()
                    if final_text:
                        self.utterance_buffer.append(final_text)
                        logger.info(f"ğŸ¤ [ë°œí™” ì™„ë£Œ] {final_text}")
                        yield final_text
                else:
                    # ì¤‘ê°„ ê²°ê³¼ëŠ” ë¡œê¹…ë§Œ (í•„ìš”ì‹œ UI ì—…ë°ì´íŠ¸ ê°€ëŠ¥)
                    pass

        except Exception as e:
            logger.error(f"âŒ [STTSession] ê²°ê³¼ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")

    def get_full_transcript(self) -> str:
        """ì „ì²´ ëŒ€í™” ë‚´ìš© ë°˜í™˜"""
        return " ".join(self.utterance_buffer)

    async def close(self):
        """ì„¸ì…˜ ì¢…ë£Œ"""
        if self.manager:
            await self.manager.stop()
        self.is_running = False

        logger.info(f"ğŸ›‘ [STTSession] ì¢…ë£Œ - Call: {self.call_sid}, "
                   f"ë°œí™”: {len(self.utterance_buffer)}ê°œ")

    def get_stats(self) -> Dict:
        """í†µê³„ ë°˜í™˜"""
        base_stats = {
            'utterance_count': len(self.utterance_buffer),
            'is_running': self.is_running
        }

        if self.manager:
            base_stats.update(self.manager.get_stats())

        return base_stats
